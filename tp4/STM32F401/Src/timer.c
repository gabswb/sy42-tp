/*
 * timer.c
 *
 *  Created on: 4 avr. 2022
 *      Author: gschwab
 */


#include "timer.h"


void TIM3_set_periodic_IRQ(uint32_t ms){

	/* définit piorité de prise en compte de l'interruption au niveau du NVIC*/
	NVIC_SetPriority(TIM3_IRQn,10);
	/* autorise les interruptions au niveau du NVIC*/
	NVIC_EnableIRQ(TIM3_IRQn);
	/*autorise IRQ sur le flag UIF*/
	TIM3->DIER |= TIM_DIER_UIE;

	TIM_set_periodic_event(ms, TIM3);

	index=0;


}
void TIM3_IRQHandler(void){
//	/* teste si le drapeau relatif à l'interruption est à '1'et test si l'interruption relative à ce drapeau est autorisée*/
 	if((TIM3->SR & TIM_SR_UIF) && (TIM3->DIER & TIM_DIER_UIE)){
 		TIM2_set_PWM(index*100);
 		index++;
		if(index>10)
			index=0;
 	}
 	/*remise à 0 du drapeau d'état*/
 	TIM3->SR &= ~TIM_SR_UIF;
}

void TIM4_set_periodic_IRQ(uint32_t ms){

	/* définit piorité de prise en compte de l'interruption au niveau du NVIC*/
	NVIC_SetPriority(TIM4_IRQn,10);
	/* autorise les interruptions au niveau du NVIC*/
	NVIC_EnableIRQ(TIM4_IRQn);

	/*autorise IRQ sur le flag CC2IF*/
	TIM4->DIER |= TIM_DIER_CC2IE;
	/*autorise IRQ sur le flag CC2IF*/
	TIM4->DIER |= TIM_DIER_CC1IE;
	/*autorise IRQ sur le flag UIF*/
	TIM4->DIER |= TIM_DIER_UIE;


	TIM_set_periodic_event(ms, TIM4);

	duration=0;
	begin=0;
	end=0;
	nb_overflows=0;

	tim_freq=ms;


}
void TIM4_IRQHandler(void){
	/* pour detecter font descendant
	 * teste si le drapeau relatif à l'interruption est à '1' et  teste si l'interruption relative à ce drapeau est autorisée*/
 	if((TIM4->SR & TIM_SR_CC2IF) && (TIM4->DIER & TIM_DIER_CC2IE)){
 		begin = TIM4->CCR2;
 		//USART2_transmit_IRQ("falling edge\r\n", 14);

 	/*remise à 0 du drapeau d'état*/
	TIM3->SR &= ~TIM_SR_CC2IF;
	nb_overflows=0;

 	}


 	if((TIM4->SR & TIM_SR_UIF) && (TIM4->DIER & TIM_DIER_UIE)){
 		nb_overflows++;

 	/*remise à 0 du drapeau d'état*/
 		TIM4->SR &= ~TIM_SR_UIF;
 	}



 	/* pour detecter font montant
 	* teste si le drapeau relatif à l'interruption est à '1' et  teste si l'interruption relative à ce drapeau est autorisée*/
 	if((TIM4->SR & TIM_SR_CC1IF_Msk) && (TIM4->DIER & TIM_DIER_CC1IE)){

		end = TIM4->CCR1;//récupération de la valeur de compteur stockée dans CCR2
		//USART2_transmit_IRQ("rising edge\r\n", 13);

		duration = compute_duration(begin, end, nb_overflows, TIM4->ARR,CK_CNT_F);

		int str_len = snprintf(buffer, 255,"begin = %d, nb_of_overflows = %d, end = %d\r\n "
											"duration : %f s\r\n", begin, nb_overflows, end,duration);
		USART2_transmit_IRQ(buffer, str_len);
		//la fréquence d'update = SystemCoreClock/(TIM4->ARR * (TIM4->PSC+1))

		duration=0;
		begin=0;
		end=0;
		nb_overflows=0;

 	/*remise à 0 du drapeau d'état*/
	TIM4->SR &= ~TIM_SR_CC1IF_Msk;
 	}


}


float compute_duration(uint16_t begin, uint16_t end, uint16_t nb_overflows, int arr, int periode)
{
	float nb_cnt = end-begin + nb_overflows*arr;//nb of tics by the counter
	float ck_cnt_T =(float) 1/CK_CNT_F;//duration of 1 tic (ck_cnt) in second

	return ck_cnt_T*nb_cnt;

}

/**
 * @brief  Setup the TIM in parameter to generate ms cycles,
 *         configured here with a ck_cnt_f = 10kHz clk for the 16 bits counter
 *         so ms can go up to 65535/10 ms (65,535 secondes)
 * @param  ms : duration of the cycle
 * @retval None
 */
 void TIM_set_periodic_event(uint32_t ms, TIM_TypeDef* tim)
 {
	/* choose the counter clock frequency. */
	uint32_t ck_cnt_f = CK_CNT_F;

	/* enable tim peripheral clock on APB1 */
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;		/* activate TIM3 Clock */

	/* set prescaler to generate a clock with ck_cnt_f frequency,
	 * it is supposed here that ck_psc frequency = SystemCoreClock */
	tim->PSC = (SystemCoreClock / ck_cnt_f ) - 1;

	/*
	 * Note ARR define the cycle duration T, depend from the ck_cnt frequency
	 * and ck_cnt frequency depend on the timer clock and the prescaler value
	 * in s : T = (ARR+1) * ck_cnt_t
	 * 			= (ARR+1) / ck_cnt_f = (ARR+1) * (PSC+1) / SystemCoreClock
	 * 			= (ARR+1) / 10000
	 * in ms : Tms = 1000 * (ARR+1) /10000 = (ARR+1)/10
	 * => ARR = 10*Tms - 1
	 * note that the autoreload register is 16 bits for TIM3 and TIM4 and
	 *  32 bits for TIM2 and TIM5 */
	tim->ARR = 10*ms - 1 ;
	/* update counter and prescaler : it clear prescaler and counter, to start
	 * with a full cycle. It will set the Update flag  (UIF), note that it can
	 * be avoided by setting the UDIS bit in CR1
	 * see TIM3_clear_periodic_event() */
	tim->EGR = TIM_EGR_UG;
	/* As an update has been generated by software,
	 * clear the bit in the status register, all flags can also be cleared
	 * here
	 */
	tim->SR &= ~ TIM_SR_UIF ;
	/* enable the counter (start counting) */
	tim->CR1 |= TIM_CR1_CEN ;
 }
