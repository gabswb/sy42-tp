#include "stm32f4xx.h"

/**
 * @brief  Setup the TIM3 to generate ms cycles,
 *         configured here with a ck_cnt_f = 10kHz clk for the 16 bits counter
 *         so ms can go up to 65535/10 ms (65,535 secondes)
 * @param  ms : duration of the cycle
 * @retval None
 */
 void TIM3_set_periodic_event(uint32_t ms)
 {
	TIM_TypeDef  * tim = TIM3;
	/* choose the counter clock frequency. */
	uint32_t ck_cnt_f = 10000;

	/* enable tim peripheral clock on APB1 */
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;		/* activate TIM3 Clock */

	/* set prescaler to generate a clock with ck_cnt_f frequency,
	 * it is supposed here that ck_psc frequency = SystemCoreClock */
	tim->PSC = (SystemCoreClock / ck_cnt_f ) - 1;

	/*
	 * Note ARR define the cycle duration T, depend from the ck_cnt frequency
	 * and ck_cnt frequency depend on the timer clock and the prescaler value
	 * in s : T = (ARR+1) * ck_cnt_t
	 * 			= (ARR+1) / ck_cnt_f = (ARR+1) * (PSC+1) / SystemCoreClock
	 * 			= (ARR+1) / 10000
	 * in ms : Tms = 1000 * (ARR+1) /10000 = (ARR+1)/10
	 * => ARR = 10*Tms - 1
	 * note that the autoreload register is 16 bits for TIM3 and TIM4 and
	 *  32 bits for TIM2 and TIM5 */
	tim->ARR = 10*ms - 1 ;
	/* update counter and prescaler : it clear prescaler and counter, to start
	 * with a full cycle. It will set the Update flag  (UIF), note that it can
	 * be avoided by setting the UDIS bit in CR1
	 * see TIM3_clear_periodic_event() */
	tim->EGR = TIM_EGR_UG;
	/* As an update has been generated by software,
	 * clear the bit in the status register, all flags can also be cleared
	 * here
	 */
	tim->SR &= ~ TIM_SR_UIF ;
	/* enable the counter (start counting) */
	tim->CR1 |= TIM_CR1_CEN ;
 }

/**
 * @brief  pure polling method (infinite wait)
 * @param  None
 * @retval None
 */
 void TIM3_wait_periodic_event(void)
 {
	/* define wich TIM */
	TIM_TypeDef  * tim = TIM3;

	/* wait for UIF flag to know if the timer has elapsed */	 
	while ((tim->SR & TIM_SR_UIF) == 0){
		// wait
	}
	/* clear UIF and return */
	tim->SR &= ~ TIM_SR_UIF ;
 }

/**
 * @brief  clear counter to re-launch a full cycle
 * @param  ms : duration of the cycle
 * @retval None
 */
void TIM3_clear_periodic_event(void)
{
	/* define wich TIM */
	TIM_TypeDef  * tim = TIM3;
	
	/* to avoid generating a update event */
	tim->CR1 |= TIM_CR1_UDIS ;
	/* clear prescaler and counter */
	tim->EGR = TIM_EGR_UG;
	/* update enable to get the next overflow */
	tim->CR1 &= ~ TIM_CR1_UDIS ;
}

/**
 * @brief  test if an update event has occurred
 * @param  None
 * @retval 1 if an update has occurred, otherwise 0
 */
uint32_t TIM3_test_periodic_event(void)
{
	/* define wich TIM */
	TIM_TypeDef  * tim = TIM3;
	
	/* test UIF flag to know if the timer has elapsed */	 
	if (tim->SR & TIM_SR_UIF){
		/* clear UIF and return */
		tim->SR &= ~ TIM_SR_UIF ;
		return 1;
 	}else
 		return 0;
}


/**
  * Pointer on the callback function. this variable (TIM3_Callback) is the
  * function address with caracteritics for the compiler, here it say that the
  * function get no parameters and return no value
  */
void (*TIM3_Callback)(void)=0;



/**
  * @brief  set the TIM to periodic interrupt with callback function
  * @param  period in millisecond, callback function
  * @retval none
  */
void TIM3_set_periodic_interrupt(uint32_t ms, void (*callback)(void))
{
	TIM_TypeDef  * tim = TIM3;
	/* choose the counter clock frequency. Here 1MHZ i chosen, so the counter
	 * will increment every 1us
	 */
	uint32_t ck_cnt_f = 1000000;

	/* enable tim peripheral clock */
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;		/* activate TIM3 Clock */

	/* set prescaler to generate a clock with ck_cnt_f frequency,
	 * it is supposed here that ck_psc frequency = SystemCoreClock */
	tim->PSC = (SystemCoreClock / ck_cnt_f ) - 1;

	/*
	 * Note ARR define the cycle duration T, depend from the ck_cnt frequency
	 * and ck_cnt frequency depend on the timer clock and the prescaler value
	 * in s : T = (ARR+1) * ck_cnt_t
	 * 			= (ARR+1) / ck_cnt_f = (ARR+1) * (PSC+1) / SystemCoreClock
	 * 			= (ARR+1) / 1000000
	 * in ms : Tms = 1000 * (ARR+1) /1000000 = (ARR+1)/1000
	 * => ARR = 1000*Tms - 1
	 * note that the autoreload register is 32 bits for TIM3 */
	tim->ARR = 1000*ms - 1 ;
	/* set ARPE to take software change of ARR only on overflow (preload)
	 * the Prescaler is by defauld preloaded */
	tim->CR1 |= TIM_CR1_ARPE;

	/* update counter and prescaler : it clear prescaler and counter, to start
	 * with a full cycle. It will set the Update flag  (UIF), note that it can
	 * be avoided by setting the UDIS bit in CR1
	 */
	tim->EGR = TIM_EGR_UG;
	/* As an update has been generated by software,
	 * clear the bit in the status register, all flags can also be cleared */
	tim->SR &= ~ TIM_SR_UIF ;

	/* configure interrupt */
	/* set the call back function with the user ones */
	TIM3_Callback = callback;
	/* set NVIC Priority for the TIM3 IRQ */
	NVIC_SetPriority(TIM3_IRQn, 10);
	/* enable NVIC for TIM3 IRQ */
	NVIC_EnableIRQ(TIM3_IRQn);
	/*Enable IRQ on UIF */
	tim->DIER |= TIM_DIER_UIE;

	/* enable the counter (start counting) */
	tim->CR1 |= TIM_CR1_CEN ;

}

/**
  * @brief  TIM3 IRQ Handler
  * @param  none
  * @retval none
  */
void TIM3_IRQHandler(void)
{
	TIM_TypeDef  * tim = TIM3;
	
	/* test uif */
	if ((tim->SR & TIM_SR_UIF) && tim->DIER & TIM_DIER_UIE){
		/* call the user callback function if set */
		if (TIM3_Callback != 0){
			TIM3_Callback();
		}
	}
	/* ack the IRQ */
	TIM3->SR &= ~ TIM_SR_UIF ;
}

/**
  * @brief  disable TIM3 periodic interrupt
  * @param  none
  * @retval none
  */
void TIM3_remove_periodic_interrupt(void)
{
	/* disable the timer */
	TIM3->CR1 &= ~TIM_CR1_CEN ;
	/*disable IRQ on UIF and CCR1 and 2 capture */
	TIM3->DIER = 0;
	/* diable NVVIC for TIM4 IRQ */
	NVIC_DisableIRQ(TIM3_IRQn);
	/* disable tim clock */
	RCC->APB1ENR &= ~RCC_APB1ENR_TIM3EN;		/* de activate TIM3 Clock */

}

/*******************************************************************************
**************************  PWM for the LED    ********************************
*******************************************************************************
*/

/**
 * @brief  Setup the TIM2 (32 bits timer) to generate a PWM
 *         configured with 100kHz clock and 1000 possible value
 *         period set to 1000/100000 = 10ms (100Hz)
 * @param  None
 * @retval None
 */
void TIM2_init_pwm(void)
{
	TIM_TypeDef  * tim = TIM2;

	/* activate TIM2 Clock */
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	/* prescaler value -> 100kHz */
	tim->PSC = (SystemCoreClock / 100000) - 1 ;
	/* autoreload register set for the counter to 10ms period*/
	tim->ARR = 1000 - 1 ;
	/* compare register 1 PWM value : CCR1/ARR*/
	tim->CCR1 = 0;	 // clear, PWM set to 0
	tim->CCER = 0 ;//clear(reset value)
	tim->CCMR1 = 0; // clear
	tim->CCMR1 = TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE; //PWM1
	tim->CCER = TIM_CCER_CC1E; /* output enable */
	tim->EGR = TIM_EGR_UG;	  // clear counter and prescaler (set the uif flag)
	tim->SR = 0;			  // Clear all interrupt flags in status register
	tim->CR1 |= TIM_CR1_CEN; // enable the counter
}

/**
 * @brief  set the value of CCR1 for PWM
 * @param  duty for CCR1
 * @retval None
 */
void TIM2_set_pwm(uint32_t duty){
	TIM2->CCR1 = duty;
}
/**
 * @brief  get the value of CCR1
 * @param  None
 * @retval value of CCR1
 */
uint32_t TIM2_get_pwm()
{
	return TIM2->CCR1;
}

/*******************************************************************************
 ********************    pulse capture function for TIM4 ***********************
 *******************************************************************************
 */

#define TI2FP2TRIG 1		// 1 : use input PWM
#define COUNT_OVERFLOW 1	// 1 : take into account counter overflow


/**
 * @brief  Initialize TIM4 to capture pulse duration, the code count also the
 * 			overflow for long pulse. 2 method can be used to get the pulse
 * 			duration :
 * 			1. use the PWM input mode by defining TI2FP2TRIG to 1, the counter
 * 			is cleared at each falling edge and the pulse duration is calculated
 * 			only from CCR1 + number of overflow
 * 			2. get the counter in CCR2 on falling edge and get the counter on
 * 			the rising edge in CCR1, substract the 2 values + overflow
 * @param  frequ : counter frequency (must be > SystemCoreClock/65536)
 *  		with 16MHz = 244, with 84MHz = 1280)
 * @retval None
 */
void TIM4_init(uint32_t frequ)
{
	TIM_TypeDef  * tim = TIM4;
	/* reset of the timer */
	RCC->APB1RSTR |= RCC_APB1RSTR_TIM4RST;
	RCC->APB1RSTR &= ~RCC_APB1RSTR_TIM4RST;
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;		/* activate TIM4 Clock */

	tim->CR1 = 2<<TIM_CR1_CKD_Pos; // filter clock set to max and other bits cleared
	/* prescaler value set to get a frequ Hz clock */
	tim->PSC = (SystemCoreClock / frequ) - 1 ;
	/* auto reload register set to its maximum value */
	tim->ARR = 0xffff ;
	/* to enable change the in CCMR for CCxS bit the channel must be off */
	tim->CCER = 0;
	/* set TIM in input mode with TI2->CCR1 and TI2->CCR2*/
	/*IC2F set to 3=> 8 f_cnt clk samples (lots of rebound on the user button) */
	/* CC1S = 10 select TI2 for IC1 (select TI2 to trigger a capture in CCR1), Chanel configured as input.*/
    /* CC2S = 01 select TI2 for IC2 (select TI2 to trigger a capture in CCR2), Chanel configured as input.*/
	tim->CCMR1 = (3<<TIM_CCMR1_IC2F_Pos) | TIM_CCMR1_CC1S_1 | TIM_CCMR1_CC2S_0;
	/* select capture on falling edge of TI2 in CCR2 and rising edge in CCR1
	   CC1NP/CC1P = 00 and CC2NP/CC2P =01*/
	tim->CCER = TIM_CCER_CC2P ;

#if TI2FP2TRIG==1 // use falling edge as trigger for counter and PSC
	/* here the counter CNT is reseted on the rising edge on TI2FP2, here it is
	 * on the falling edge of TI2 (this mode is the 'input PWM')
	 * Configure the timer in reset mode by writing SMS=100 in TIMx_SMCR
	 * Select TI2 as the input source by writing TS=110 in TIMx_SMCR register.*/
	tim->SMCR &= ~(TIM_SMCR_TS_Msk | TIM_SMCR_SMS_Msk);
	tim->SMCR |= (0b110<<TIM_SMCR_TS_Pos) | (0b100<<TIM_SMCR_SMS_Pos);
#endif	//TI2FP2TRIG
	/* input capture enable */
	tim->CCER |= TIM_CCER_CC1E | TIM_CCER_CC2E;

	tim->EGR = TIM_EGR_UG;			/* clear counter and prescaler (set the uif flag) */
	tim->SR = 0;					/* Clear all flags in status register */
	tim->CR1 |= TIM_CR1_CEN ;		/* enable the counter */

}


#if COUNT_OVERFLOW == 0  // simple version, for short pulse
/**
 * @brief  wait and compute the duration of a negative pulse.
 * 			it use CCR2 of TIM4 to capture the counter on a falling edge of
 * 			the signal and CCR1 to capture the counter on the rising edge
 * 			Overflow are not taken into account.
 * 			the counter can be reseted at the beginning of the pulse (falling
 * 			edge)
 * @param  None
 * @retval None
 */
uint32_t TIM4_wait_pulse_capture(void)
{
	TIM_TypeDef  * tim = TIM4;
	uint32_t pulse=0, overflow=0;
	uint32_t test1, test2, test3;

	/* Optionally start again the counter to wait for a new pulse
	 * otherwise an old pulse could have been memorized in CCR1 */
//	tim->EGR = TIM_EGR_UG;			/* clear counter and prescaler (set the uif flag) */
//	tim->SR = 0;					/* Clear all flags in status register */

	/* wait for the capture of CNT in CCR1 (end of pulse) */
	while (!(tim->SR & TIM_SR_CC1IF)){
	}
	/* calculate the pulse duration */
	pulse = tim->CCR1;

#if TI2FP2TRIG==0	// the counter run free (no trigger)
	/* in this case, CCR2 contain the value corresponding to the start of the
	 * pulse and CCR1 the value corresponding to the end of the pulse
	 */
	if (tim->CCR1 > tim->CCR2){
		pulse = (pulse - tim->CCR2); // overflow = 0x10000 ticks on 16 bits counter
	}
	else {
		pulse += 0x10000 ; // add full period (ARR+1)
		pulse -= tim->CCR2 ;
	}
#endif

	tim->SR=0; 						/*clear all flags */

	return pulse;
	//in ms : (pulse*tim->PSC)/(SystemCoreClock/1000); // (pulse*1000/frequ)

}
#else //COUNT_OVERFLOW==1
/**
 * @brief  wait and compute the duration of a negative pulse.
 * 			it use CCR2 of TIM4 to capture the counter on a falling edge of
 * 			the signal and CCR1 to capture the counter on the rising edge
 * 			Overflow are taken into account.
 * 			the counter can be reseted at the beginning of the pulse (falling
 * 			edge)
 * @param  None
 * @retval None
 */
uint32_t TIM4_pulse_capture(void)
{
	TIM_TypeDef  * tim = TIM4;
	uint32_t pulse=0, overflow=0;

	/* reset flags and restart the counter to start to get an
	 * entire pulse (overflow must be counted !! )*/
	tim->EGR = TIM_EGR_UG;			/* clear counter and prescaler (set the uif flag) */
	tim->SR = 0;					/* Clear all flags in status register */

	/* wait for the capture of CNT in CCR1 (end of pulse) */
	while (!(tim->SR & TIM_SR_CC1IF)){
		/* test falling edge to reset overflow in case of overflow counting
		 * for long pulses*/
		if (tim->SR & TIM_SR_CC2IF){
			overflow=0;
			tim->SR &= ~(TIM_SR_UIF | TIM_SR_CC2IF);
		}

		/* test overflow and count them (for particularly long pulses) */
		if (tim->SR & TIM_SR_UIF){
			overflow += 1;
			tim->SR &= ~TIM_SR_UIF;
		}
	}

	/* calculate the pulse duration, take into account overflows */
	pulse = tim->CCR1;

#if TI2FP2TRIG==1		// use falling edge as trigger for counter
	/* in this case, CCR1 contain the duration, as CNT has been
	 * reseted at the falling edge of the signal, the number of overflow can be
	 * added
	 */
	pulse = (pulse)+overflow*0x10000;
#else					// the counter run free (no trigger)
	/* in this case, CCR2 contain the value corresponding to the start of the
	 * pulse and CCR1 the value corresponding to the end of the pulse
	 * the number of overflow can be added
	 */
	if (tim->CCR1 > tim->CCR2){
		pulse = (pulse - tim->CCR2)+overflow*0x10000; // overflow = 0x10000 ticks on 16 bits counter
	}
	else {
		if (overflow > 0){
			pulse += 0x10000 ; // add full period
			pulse -= tim->CCR2 ;
			pulse +=(overflow-1)*0x10000;
		}else
			pulse=0; /* CCR2 contain a value captured before the one in CCR1, negative pulse duration !! */
	}
#endif

	tim->SR=0; 						/*clear all flags */

	return pulse;
	//in ms : (pulse*tim->PSC)/(SystemCoreClock/1000); // (pulse*1000/frequ)

}
#endif //COUNT_OVERFLOW

/********************* Periodic polling method *******************************/

/* pulse capture data that are shared between TIM4 function */
uint32_t TIM4_pulse=0;
uint32_t TIM4_overflow=0;

/**
 * @brief  polling method to test capture flags :
 * 			if a falling edge has occurred (TIM_SR_CC2IF), overflow is reseted
 * 			if an overflow (update event) has occured the overflow counter is
 * 				incremented (TIM4_overflow)
 * 			if a rising edge has occurred the capture is done
 * @param  none
 * @retval 1 if a capture has been done, 0 otherwise
 */
int32_t TIM4_test_pulse_capture(void)
{
	uint32_t pulse;
	TIM_TypeDef  * tim = TIM4;


	/* test for the falling edge that is the start of the negative pulse
	 * (capture of CNT in CCR2) */
	if (tim->SR & TIM_SR_CC2IF){
		/* reset overflow */
		TIM4_overflow=0;
		/* clear the flag capture */
		tim->SR &= ~TIM_SR_CC2IF;
#if TI2FP2TRIG==1 //(trigger on falling edge)
		/* clear update flag, as a trigger has been generated */
		tim->SR &= ~TIM_SR_UIF;
#endif
	}

	/* test overflow */
	if (tim->SR & TIM_SR_UIF){
		TIM4_overflow += 1;
		tim->SR &= ~TIM_SR_UIF;
	}
	/* test the capture of CNT in CCR1 (end of pulse) */
	if ((tim->SR & TIM_SR_CC1IF)){
		pulse = tim->CCR1;
#if TI2FP2TRIG==1
		/* in this case, CCR1 contain the duration, as CNT has been
		 * reseted at the falling edge of the signal, the number of overflow can
		 * be added
		 */
		pulse = pulse+TIM4_overflow*0x10000;
#else	//TI2FP2TRIG==0
		/* in this case, CCR2 contain the value corresponding to the start of
		 * the pulse and CCR1 the value corresponding to the end of the pulse
		 * the number of overflow can be added. Each overflow is a full counter
		 * with ARR = 0xFFFF, so 0x10000
		 */
		if (tim->CCR1 > tim->CCR2){
			pulse = (pulse - tim->CCR2)+TIM4_overflow*0x10000;
		}
		else {
			if (TIM4_overflow > 0){
				pulse += 0x10000 ; // add full period
				pulse -= tim->CCR2 ;
				pulse +=(TIM4_overflow-1)*0x10000;
			}else
				pulse=0; // should never reach
		}
#endif //TI2FP2TRIG

		/* set the global variable for the main application */
		TIM4_pulse = pulse; //(pulse*tim->PSC)/(SystemCoreClock/1000) in ms

		/* return 1 to signal that a capture has been done, note that
		 * no overrun error is checked
		 */
		return 1;
	}
	/* still waiting for the rising edge to end the capture */
	return 0;
}



/**
 * @brief  get the pulse in ticks
 * @param  none
 * @retval pulse duration in ticks
 */
uint32_t TIM4_get_pulse(void)
{
	return TIM4_pulse;
}


/**
 * @brief  Setup the TIM5 to count (for FreeRTOS profiling),
 * @param  freq : frequency of counting
 * @retval None
 */
 void TIM5_Init(uint32_t freq)
 {
	TIM_TypeDef  * tim = TIM5;
	RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;		/* activate TIM5 Clock */

	/* prescaler value set to get a freq Hz clock */
	tim->PSC = (SystemCoreClock / freq) - 1 ;
	/* auto reload register set to its maximum value (32 bits) */
	tim->ARR = 0xffffffff;
	/* to enable change the in CCMR for CCxS bit the channel must be off */
	tim->CCER = 0;
	 	/* update counter and prescaler : it clear prescaler and counter, to start
	 * with a full cycle. It will set the Update flag  (UIF), note that it can
	 * be avoided by setting the UDIS bit in CR1
	 * see TIM5_clear_periodic_event() */
	tim->EGR = TIM_EGR_UG;
	/* As an update has been generated by software,
	 * clear the bit in the status register, all flags can also be cleared
	 * here
	 */
	tim->SR &= ~ TIM_SR_UIF ;
	/* enable the counter (start counting) */
	tim->CR1 |= TIM_CR1_CEN ;
 }

 uint32_t TIM5_get_cnt(void)
 {
	TIM_TypeDef  * tim = TIM5;
	return tim->CNT;

 }
